<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy Generator - MobileCLI Demos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.3);
        }

        .info {
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 280px;
        }

        .info h3 {
            color: #a855f7;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.3);
        }

        .particle-count {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #a855f7;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 600px) {
            .info { display: none; }
            .ui { top: 10px; left: 10px; }
        }
    </style>
</head>
<body>
    <div class="ui">
        <a href="/demos.html" class="back-btn">‚Üê Back to Demos</a>
        <div class="info">
            <h3>Galaxy Generator</h3>
            <p>100,000 particles forming a spiral galaxy with dust lanes and orbital mechanics. Drag to rotate, pinch to zoom.</p>
        </div>
    </div>

    <div class="particle-count" id="particleCount">100,000 particles</div>

    <div class="controls">
        <button class="control-btn" onclick="regenerate()">New Galaxy</button>
        <button class="control-btn" onclick="toggleRotation()">Pause Rotation</button>
        <button class="control-btn" onclick="toggleColors()">Change Colors</button>
        <button class="control-btn" onclick="toggleArms()">More Arms</button>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Galaxy parameters
        let params = {
            count: 100000,
            size: 0.01,
            radius: 5,
            branches: 3,
            spin: 1,
            randomness: 0.2,
            randomnessPower: 3,
            insideColor: '#ff6030',
            outsideColor: '#1b3984',
            rotating: true,
            colorScheme: 0
        };

        const colorSchemes = [
            { inside: '#ff6030', outside: '#1b3984' },
            { inside: '#00ff88', outside: '#0066ff' },
            { inside: '#a855f7', outside: '#00d4ff' },
            { inside: '#ff0066', outside: '#ffff00' },
            { inside: '#ffffff', outside: '#6633ff' }
        ];

        let galaxy = null;
        let geometry = null;
        let material = null;

        // Generate galaxy
        function generateGalaxy() {
            // Dispose old galaxy
            if (galaxy !== null) {
                geometry.dispose();
                material.dispose();
                scene.remove(galaxy);
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.count * 3);
            const colors = new Float32Array(params.count * 3);
            const scales = new Float32Array(params.count);

            const colorInside = new THREE.Color(params.insideColor);
            const colorOutside = new THREE.Color(params.outsideColor);

            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;

                // Position
                const radius = Math.random() * params.radius;
                const spinAngle = radius * params.spin;
                const branchAngle = (i % params.branches) / params.branches * Math.PI * 2;

                const randomX = Math.pow(Math.random(), params.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * params.randomness * radius;
                const randomY = Math.pow(Math.random(), params.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * params.randomness * radius * 0.3;
                const randomZ = Math.pow(Math.random(), params.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * params.randomness * radius;

                positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                positions[i3 + 1] = randomY;
                positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                // Color
                const mixedColor = colorInside.clone();
                mixedColor.lerp(colorOutside, radius / params.radius);

                colors[i3] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;

                // Size variation
                scales[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));

            // Material
            material = new THREE.PointsMaterial({
                size: params.size,
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            galaxy = new THREE.Points(geometry, material);
            scene.add(galaxy);

            document.getElementById('particleCount').textContent = params.count.toLocaleString() + ' particles';
        }

        generateGalaxy();

        // Add central glow
        const glowGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffaa,
            transparent: true,
            opacity: 0.6
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);

        // Add outer halo
        const haloGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const haloMaterial = new THREE.MeshBasicMaterial({
            color: params.insideColor,
            transparent: true,
            opacity: 0.3
        });
        const halo = new THREE.Mesh(haloGeometry, haloMaterial);
        scene.add(halo);

        // Mouse/touch controls
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let targetRotationX = 0.5;
        let targetRotationY = 0;
        let currentRotationX = 0.5;
        let currentRotationY = 0;
        let autoRotate = true;

        function getPosition(e) {
            return {
                x: e.touches ? e.touches[0].clientX : e.clientX,
                y: e.touches ? e.touches[0].clientY : e.clientY
            };
        }

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousPosition = getPosition(e);
            autoRotate = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const pos = getPosition(e);
            targetRotationY += (pos.x - previousPosition.x) * 0.005;
            targetRotationX += (pos.y - previousPosition.y) * 0.005;
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
            previousPosition = pos;
        });

        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mouseleave', () => { isDragging = false; });

        document.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousPosition = getPosition(e);
            autoRotate = false;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const pos = getPosition(e);
            targetRotationY += (pos.x - previousPosition.x) * 0.005;
            targetRotationX += (pos.y - previousPosition.y) * 0.005;
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
            previousPosition = pos;
        }, { passive: true });

        document.addEventListener('touchend', () => { isDragging = false; });

        // Zoom
        let targetZoom = 15;
        document.addEventListener('wheel', (e) => {
            targetZoom += e.deltaY * 0.01;
            targetZoom = Math.max(5, Math.min(30, targetZoom));
        });

        // Pinch zoom for mobile
        let initialPinchDistance = 0;
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const delta = initialPinchDistance - distance;
                targetZoom += delta * 0.02;
                targetZoom = Math.max(5, Math.min(30, targetZoom));
                initialPinchDistance = distance;
            }
        }, { passive: true });

        // Control functions
        window.regenerate = function() {
            generateGalaxy();
        };

        window.toggleRotation = function() {
            params.rotating = !params.rotating;
        };

        window.toggleColors = function() {
            params.colorScheme = (params.colorScheme + 1) % colorSchemes.length;
            params.insideColor = colorSchemes[params.colorScheme].inside;
            params.outsideColor = colorSchemes[params.colorScheme].outside;
            haloMaterial.color.set(params.insideColor);
            generateGalaxy();
        };

        window.toggleArms = function() {
            params.branches = params.branches === 3 ? 5 : params.branches === 5 ? 7 : 3;
            generateGalaxy();
        };

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Auto rotate
            if (autoRotate) {
                targetRotationY += 0.001;
            }

            // Smooth camera rotation
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;

            camera.position.x = Math.sin(currentRotationY) * targetZoom * Math.cos(currentRotationX);
            camera.position.y = Math.sin(currentRotationX) * targetZoom;
            camera.position.z = Math.cos(currentRotationY) * targetZoom * Math.cos(currentRotationX);
            camera.lookAt(0, 0, 0);

            // Smooth zoom
            const currentZoom = camera.position.length();
            camera.position.multiplyScalar(1 + (targetZoom - currentZoom) * 0.05 / currentZoom);

            // Rotate galaxy
            if (galaxy && params.rotating) {
                galaxy.rotation.y = elapsedTime * 0.05;
            }

            // Pulse central glow
            const scale = 1 + Math.sin(elapsedTime * 2) * 0.1;
            glow.scale.set(scale, scale, scale);
            halo.scale.set(scale * 1.5, scale * 1.5, scale * 1.5);

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
