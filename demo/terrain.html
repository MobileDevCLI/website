<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Terrain Generator - MobileCLI Demos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(0, 180, 100, 0.2);
            border-color: rgba(0, 180, 100, 0.3);
        }

        .info {
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 280px;
        }

        .info h3 {
            color: #00b464;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(0, 180, 100, 0.2);
            border-color: rgba(0, 180, 100, 0.3);
        }

        .control-btn.active {
            background: rgba(0, 180, 100, 0.3);
            border-color: #00b464;
            color: #00b464;
        }

        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #00b464;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 600px) {
            .info { display: none; }
            .ui { top: 10px; left: 10px; }
        }
    </style>
</head>
<body>
    <div class="ui">
        <a href="/demos.html" class="back-btn">‚Üê Back to Demos</a>
        <div class="info">
            <h3>Terrain Generator</h3>
            <p>Procedural terrain with Perlin noise. Drag to rotate, scroll/pinch to zoom. Generate new worlds!</p>
        </div>
    </div>

    <div class="stats" id="stats">Vertices: 0</div>

    <div class="controls">
        <button class="control-btn" onclick="regenerate()">New Terrain</button>
        <button class="control-btn" onclick="toggleWireframe()">Wireframe</button>
        <button class="control-btn" onclick="toggleWater()">Water</button>
        <button class="control-btn" onclick="toggleFlythrough()">Flythrough</button>
    </div>

    <script>
        // Perlin noise implementation
        class PerlinNoise {
            constructor(seed = Math.random()) {
                this.perm = [];
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;

                // Shuffle based on seed
                let s = seed;
                for (let i = 255; i > 0; i--) {
                    s = (s * 16807) % 2147483647;
                    const j = Math.floor((s / 2147483647) * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }

                for (let i = 0; i < 512; i++) {
                    this.perm[i] = p[i & 255];
                }
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

            lerp(t, a, b) { return a + t * (b - a); }

            grad(hash, x, y) {
                const h = hash & 7;
                const u = h < 4 ? x : y;
                const v = h < 4 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;

                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
                );
            }

            fbm(x, y, octaves = 6) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise(x * frequency, y * frequency);
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }

                return value / maxValue;
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(50, 40, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x87ceeb);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // Terrain parameters
        const terrainSize = 100;
        const segments = 128;
        let terrain = null;
        let water = null;
        let wireframe = false;
        let showWater = true;
        let flythrough = false;

        // Generate terrain
        function generateTerrain() {
            const perlin = new PerlinNoise();
            const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            const colors = [];

            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];

                // Multi-octave height
                const nx = x / terrainSize;
                const nz = z / terrainSize;
                let height = perlin.fbm(nx * 4, nz * 4, 6) * 20;

                // Add some ridges
                height += Math.abs(perlin.fbm(nx * 8, nz * 8, 3)) * 10;

                vertices[i + 1] = height;

                // Color based on height
                let color;
                if (height < 0) {
                    color = new THREE.Color(0x1a5276); // Deep water
                } else if (height < 2) {
                    color = new THREE.Color(0xf4d03f); // Beach
                } else if (height < 8) {
                    color = new THREE.Color(0x27ae60); // Grass
                } else if (height < 15) {
                    color = new THREE.Color(0x1e8449); // Forest
                } else if (height < 22) {
                    color = new THREE.Color(0x7b7d7d); // Rock
                } else {
                    color = new THREE.Color(0xffffff); // Snow
                }

                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                wireframe: wireframe
            });

            if (terrain) scene.remove(terrain);
            terrain = new THREE.Mesh(geometry, material);
            scene.add(terrain);

            // Update stats
            document.getElementById('stats').textContent = `Vertices: ${(vertices.length / 3).toLocaleString()}`;
        }

        // Create water plane
        function createWater() {
            const waterGeometry = new THREE.PlaneGeometry(terrainSize * 1.5, terrainSize * 1.5);
            waterGeometry.rotateX(-Math.PI / 2);

            const waterMaterial = new THREE.MeshBasicMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.6
            });

            if (water) scene.remove(water);
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.y = 1;
            if (showWater) scene.add(water);
        }

        // Initialize
        generateTerrain();
        createWater();

        // Controls
        let isDragging = false;
        let previousPos = { x: 0, y: 0 };
        let targetRotationY = 0;
        let targetRotationX = 0.5;
        let currentRotationY = 0;
        let currentRotationX = 0.5;
        let targetZoom = 80;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousPos = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            targetRotationY += (e.clientX - previousPos.x) * 0.005;
            targetRotationX += (e.clientY - previousPos.y) * 0.005;
            targetRotationX = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, targetRotationX));
            previousPos = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mouseleave', () => { isDragging = false; });

        document.addEventListener('wheel', (e) => {
            targetZoom += e.deltaY * 0.1;
            targetZoom = Math.max(30, Math.min(150, targetZoom));
        });

        // Touch controls
        let pinchDistance = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                pinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                targetRotationY += (e.touches[0].clientX - previousPos.x) * 0.005;
                targetRotationX += (e.touches[0].clientY - previousPos.y) * 0.005;
                targetRotationX = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, targetRotationX));
                previousPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDistance = Math.sqrt(dx * dx + dy * dy);

                if (pinchDistance > 0) {
                    targetZoom -= (newDistance - pinchDistance) * 0.2;
                    targetZoom = Math.max(30, Math.min(150, targetZoom));
                }
                pinchDistance = newDistance;
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            isDragging = false;
            pinchDistance = 0;
        });

        // Control functions
        window.regenerate = function() {
            generateTerrain();
            createWater();
        };

        window.toggleWireframe = function() {
            wireframe = !wireframe;
            if (terrain) terrain.material.wireframe = wireframe;
            document.querySelectorAll('.control-btn')[1].classList.toggle('active', wireframe);
        };

        window.toggleWater = function() {
            showWater = !showWater;
            if (showWater) {
                scene.add(water);
            } else {
                scene.remove(water);
            }
            document.querySelectorAll('.control-btn')[2].classList.toggle('active', !showWater);
        };

        window.toggleFlythrough = function() {
            flythrough = !flythrough;
            document.querySelectorAll('.control-btn')[3].classList.toggle('active', flythrough);
        };

        // Animation
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Smooth camera movement
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;

            if (flythrough) {
                // Automatic flythrough
                targetRotationY += 0.003;
                camera.position.x = Math.sin(time * 0.2) * 60;
                camera.position.z = Math.cos(time * 0.2) * 60;
                camera.position.y = 30 + Math.sin(time * 0.5) * 10;
            } else {
                camera.position.x = Math.sin(currentRotationY) * targetZoom * Math.cos(currentRotationX);
                camera.position.z = Math.cos(currentRotationY) * targetZoom * Math.cos(currentRotationX);
                camera.position.y = Math.sin(currentRotationX) * targetZoom;
            }

            camera.lookAt(0, 5, 0);

            // Animate water
            if (water) {
                water.position.y = 1 + Math.sin(time) * 0.3;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
