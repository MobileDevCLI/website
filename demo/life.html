<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Game of Life - MobileCLI Demos</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .info {
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 280px;
        }

        .info h3 {
            color: #00ff88;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .control-btn.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
            color: #00ff88;
        }

        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #00ff88;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 600px) {
            .info { display: none; }
            .ui { top: 10px; left: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui">
        <a href="/demos.html" class="back-btn">‚Üê Back to Demos</a>
        <div class="info">
            <h3>Conway's Game of Life</h3>
            <p>GPU-accelerated cellular automaton. Tap to draw cells. Watch patterns emerge and evolve.</p>
        </div>
    </div>

    <div class="stats" id="stats">Generation: 0</div>

    <div class="controls">
        <button class="control-btn" onclick="togglePause()">Pause</button>
        <button class="control-btn" onclick="clearGrid()">Clear</button>
        <button class="control-btn" onclick="randomize()">Random</button>
        <button class="control-btn" onclick="addGliderGun()">Glider Gun</button>
        <button class="control-btn" onclick="toggleColors()">Colors</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        let width, height, gridWidth, gridHeight;
        const cellSize = 4;
        let generation = 0;
        let paused = false;
        let colorMode = 0;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            gridWidth = Math.floor(width / cellSize);
            gridHeight = Math.floor(height / cellSize);
            gl.viewport(0, 0, width, height);
        }
        resize();
        window.addEventListener('resize', () => {
            resize();
            initTextures();
            randomize();
        });

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader for simulation step
        const simulationShaderSource = `
            precision mediump float;
            uniform sampler2D u_state;
            uniform vec2 u_resolution;
            varying vec2 v_texCoord;

            int getCell(vec2 offset) {
                vec2 coord = v_texCoord + offset / u_resolution;
                vec4 cell = texture2D(u_state, coord);
                return cell.r > 0.5 ? 1 : 0;
            }

            void main() {
                int neighbors = 0;

                // Count 8 neighbors
                neighbors += getCell(vec2(-1.0, -1.0));
                neighbors += getCell(vec2( 0.0, -1.0));
                neighbors += getCell(vec2( 1.0, -1.0));
                neighbors += getCell(vec2(-1.0,  0.0));
                neighbors += getCell(vec2( 1.0,  0.0));
                neighbors += getCell(vec2(-1.0,  1.0));
                neighbors += getCell(vec2( 0.0,  1.0));
                neighbors += getCell(vec2( 1.0,  1.0));

                int alive = getCell(vec2(0.0, 0.0));

                // Conway's rules
                if (alive == 1 && (neighbors == 2 || neighbors == 3)) {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                } else if (alive == 0 && neighbors == 3) {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            }
        `;

        // Fragment shader for rendering with colors
        const renderShaderSource = `
            precision mediump float;
            uniform sampler2D u_state;
            uniform int u_colorMode;
            uniform float u_time;
            varying vec2 v_texCoord;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec4 cell = texture2D(u_state, v_texCoord);

                if (cell.r > 0.5) {
                    if (u_colorMode == 0) {
                        // Green matrix style
                        gl_FragColor = vec4(0.0, 1.0, 0.533, 1.0);
                    } else if (u_colorMode == 1) {
                        // Rainbow based on position
                        float hue = v_texCoord.x + v_texCoord.y + u_time * 0.1;
                        vec3 color = hsv2rgb(vec3(hue, 0.8, 1.0));
                        gl_FragColor = vec4(color, 1.0);
                    } else if (u_colorMode == 2) {
                        // Cyan neon
                        gl_FragColor = vec4(0.0, 0.83, 1.0, 1.0);
                    } else {
                        // Purple
                        gl_FragColor = vec4(0.66, 0.33, 0.97, 1.0);
                    }
                } else {
                    // Background with subtle glow
                    float glow = cell.r * 0.3;
                    gl_FragColor = vec4(glow * 0.0, glow * 0.2, glow * 0.1, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const simulationProgram = createProgram(vertexShaderSource, simulationShaderSource);
        const renderProgram = createProgram(vertexShaderSource, renderShaderSource);

        // Get locations
        const simLocations = {
            position: gl.getAttribLocation(simulationProgram, 'a_position'),
            state: gl.getUniformLocation(simulationProgram, 'u_state'),
            resolution: gl.getUniformLocation(simulationProgram, 'u_resolution')
        };

        const renderLocations = {
            position: gl.getAttribLocation(renderProgram, 'a_position'),
            state: gl.getUniformLocation(renderProgram, 'u_state'),
            colorMode: gl.getUniformLocation(renderProgram, 'u_colorMode'),
            time: gl.getUniformLocation(renderProgram, 'u_time')
        };

        // Create full-screen quad
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,   1, -1,   1, 1
        ]), gl.STATIC_DRAW);

        // Textures and framebuffers for ping-pong
        let textures = [];
        let framebuffers = [];
        let currentState = 0;

        function initTextures() {
            // Clean up old textures
            for (const tex of textures) gl.deleteTexture(tex);
            for (const fb of framebuffers) gl.deleteFramebuffer(fb);
            textures = [];
            framebuffers = [];

            for (let i = 0; i < 2; i++) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridWidth, gridHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                textures.push(texture);

                const fb = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                framebuffers.push(fb);
            }
        }

        initTextures();

        // Initialize with random pattern
        function randomize() {
            const data = new Uint8Array(gridWidth * gridHeight * 4);
            for (let i = 0; i < data.length; i += 4) {
                const alive = Math.random() > 0.7 ? 255 : 0;
                data[i] = alive;
                data[i + 1] = alive;
                data[i + 2] = alive;
                data[i + 3] = 255;
            }
            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridWidth, gridHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            generation = 0;
        }

        function clearGrid() {
            const data = new Uint8Array(gridWidth * gridHeight * 4);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = 0;
                data[i + 3] = 255;
            }
            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridWidth, gridHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            generation = 0;
        }

        // Draw cells at position
        function drawCells(x, y, radius = 3) {
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor((height - y) / cellSize);

            const data = new Uint8Array(gridWidth * gridHeight * 4);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.readPixels(0, 0, gridWidth, gridHeight, gl.RGBA, gl.UNSIGNED_BYTE, data);

            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const px = gridX + dx;
                        const py = gridY + dy;
                        if (px >= 0 && px < gridWidth && py >= 0 && py < gridHeight) {
                            const idx = (py * gridWidth + px) * 4;
                            data[idx] = 255;
                            data[idx + 1] = 255;
                            data[idx + 2] = 255;
                        }
                    }
                }
            }

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridWidth, gridHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }

        // Add Gosper Glider Gun
        function addGliderGun() {
            const data = new Uint8Array(gridWidth * gridHeight * 4);
            for (let i = 0; i < data.length; i += 4) data[i + 3] = 255;

            const gun = [
                [24, 0], [22, 1], [24, 1], [12, 2], [13, 2], [20, 2], [21, 2], [34, 2], [35, 2],
                [11, 3], [15, 3], [20, 3], [21, 3], [34, 3], [35, 3], [0, 4], [1, 4], [10, 4],
                [16, 4], [20, 4], [21, 4], [0, 5], [1, 5], [10, 5], [14, 5], [16, 5], [17, 5],
                [22, 5], [24, 5], [10, 6], [16, 6], [24, 6], [11, 7], [15, 7], [12, 8], [13, 8]
            ];

            const offsetX = Math.floor(gridWidth / 4);
            const offsetY = Math.floor(gridHeight / 2);

            for (const [x, y] of gun) {
                const px = offsetX + x;
                const py = offsetY + y;
                if (px >= 0 && px < gridWidth && py >= 0 && py < gridHeight) {
                    const idx = (py * gridWidth + px) * 4;
                    data[idx] = 255;
                    data[idx + 1] = 255;
                    data[idx + 2] = 255;
                }
            }

            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridWidth, gridHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            generation = 0;
        }

        // Mouse/touch handling
        let isDrawing = false;

        function getPos(e) {
            return {
                x: e.touches ? e.touches[0].clientX : e.clientX,
                y: e.touches ? e.touches[0].clientY : e.clientY
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const pos = getPos(e);
            drawCells(pos.x, pos.y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getPos(e);
            drawCells(pos.x, pos.y);
        });

        canvas.addEventListener('mouseup', () => { isDrawing = false; });
        canvas.addEventListener('mouseleave', () => { isDrawing = false; });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const pos = getPos(e);
            drawCells(pos.x, pos.y);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const pos = getPos(e);
            drawCells(pos.x, pos.y);
        }, { passive: false });

        canvas.addEventListener('touchend', () => { isDrawing = false; });

        // Control functions
        window.togglePause = function() {
            paused = !paused;
            document.querySelectorAll('.control-btn')[0].classList.toggle('active', paused);
        };

        window.clearGrid = clearGrid;
        window.randomize = randomize;
        window.addGliderGun = addGliderGun;

        window.toggleColors = function() {
            colorMode = (colorMode + 1) % 4;
        };

        // Simulation step
        function step() {
            // Bind framebuffer of next state
            const nextState = 1 - currentState;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[nextState]);
            gl.viewport(0, 0, gridWidth, gridHeight);

            // Use simulation program
            gl.useProgram(simulationProgram);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.uniform1i(simLocations.state, 0);
            gl.uniform2f(simLocations.resolution, gridWidth, gridHeight);

            // Draw
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(simLocations.position);
            gl.vertexAttribPointer(simLocations.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            currentState = nextState;
            generation++;
        }

        // Render
        function render(time) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, width, height);

            gl.useProgram(renderProgram);
            gl.bindTexture(gl.TEXTURE_2D, textures[currentState]);
            gl.uniform1i(renderLocations.state, 0);
            gl.uniform1i(renderLocations.colorMode, colorMode);
            gl.uniform1f(renderLocations.time, time * 0.001);

            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(renderLocations.position);
            gl.vertexAttribPointer(renderLocations.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Animation loop
        let lastStep = 0;
        const stepInterval = 50; // ms between steps

        function animate(time) {
            requestAnimationFrame(animate);

            if (!paused && time - lastStep > stepInterval) {
                step();
                lastStep = time;
            }

            render(time);
            document.getElementById('stats').textContent = `Generation: ${generation}`;
        }

        randomize();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
