<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fractal Explorer - MobileCLI Demos</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        canvas {
            display: block;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.3);
        }

        .info {
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 280px;
        }

        .info h3 {
            color: #a855f7;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.3);
        }

        .control-btn.active {
            background: rgba(168, 85, 247, 0.3);
            border-color: #a855f7;
            color: #a855f7;
        }

        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #a855f7;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            backdrop-filter: blur(10px);
            text-align: right;
        }

        @media (max-width: 600px) {
            .info { display: none; }
            .ui { top: 10px; left: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui">
        <a href="/demos.html" class="back-btn">‚Üê Back to Demos</a>
        <div class="info">
            <h3>Fractal Explorer</h3>
            <p>GPU-rendered Mandelbrot and Julia sets. Drag to pan, pinch/scroll to zoom. Explore infinite detail.</p>
        </div>
    </div>

    <div class="stats" id="stats">Zoom: 1x</div>

    <div class="controls">
        <button class="control-btn" onclick="resetView()">Reset</button>
        <button class="control-btn" onclick="toggleFractal()">Julia Set</button>
        <button class="control-btn" onclick="toggleColors()">Colors</button>
        <button class="control-btn" onclick="increaseIterations()">Detail+</button>
        <button class="control-btn" onclick="animateJulia()">Animate</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            gl.viewport(0, 0, width, height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Fractal parameters
        let centerX = -0.5;
        let centerY = 0;
        let zoom = 1;
        let maxIterations = 100;
        let colorScheme = 0;
        let fractalType = 0; // 0 = Mandelbrot, 1 = Julia
        let juliaC = { x: -0.7, y: 0.27015 };
        let animating = false;
        let animationTime = 0;

        const colorSchemes = [
            'classic',
            'fire',
            'ocean',
            'neon',
            'grayscale'
        ];

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform vec2 u_resolution;

            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);

                float aspect = u_resolution.x / u_resolution.y;
                v_coord = a_position * vec2(aspect, 1.0) / u_zoom + u_center;
            }
        `;

        // Fragment shader with multiple fractals and color schemes
        const fragmentShaderSource = `
            precision highp float;
            varying vec2 v_coord;
            uniform int u_maxIterations;
            uniform int u_colorScheme;
            uniform int u_fractalType;
            uniform vec2 u_juliaC;
            uniform float u_time;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            vec3 getColor(float t, int scheme) {
                if (scheme == 0) {
                    // Classic rainbow
                    return hsv2rgb(vec3(t, 1.0, 1.0));
                } else if (scheme == 1) {
                    // Fire
                    return vec3(
                        min(1.0, t * 3.0),
                        max(0.0, t * 3.0 - 1.0),
                        max(0.0, t * 3.0 - 2.0)
                    );
                } else if (scheme == 2) {
                    // Ocean
                    return vec3(
                        0.0,
                        t * 0.5 + 0.2,
                        t * 0.8 + 0.2
                    );
                } else if (scheme == 3) {
                    // Neon
                    float h = t * 0.3 + 0.75;
                    return hsv2rgb(vec3(h, 0.9, 1.0));
                } else {
                    // Grayscale
                    return vec3(t);
                }
            }

            void main() {
                vec2 z, c;

                if (u_fractalType == 0) {
                    // Mandelbrot: z starts at 0, c is the coordinate
                    z = vec2(0.0);
                    c = v_coord;
                } else {
                    // Julia: z starts at coordinate, c is constant
                    z = v_coord;
                    c = u_juliaC;
                }

                int iterations = 0;

                for (int i = 0; i < 1000; i++) {
                    if (i >= u_maxIterations) break;

                    // z = z^2 + c
                    float x = z.x * z.x - z.y * z.y + c.x;
                    float y = 2.0 * z.x * z.y + c.y;
                    z = vec2(x, y);

                    if (z.x * z.x + z.y * z.y > 4.0) break;
                    iterations++;
                }

                if (iterations >= u_maxIterations) {
                    // Inside the set
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Outside - smooth coloring
                    float mu = float(iterations) - log(log(length(z))) / log(2.0);
                    float t = mu / float(u_maxIterations);
                    t = fract(t * 3.0 + u_time * 0.05);

                    vec3 color = getColor(t, u_colorScheme);
                    gl_FragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Get locations
        const locations = {
            position: gl.getAttribLocation(program, 'a_position'),
            center: gl.getUniformLocation(program, 'u_center'),
            zoom: gl.getUniformLocation(program, 'u_zoom'),
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            maxIterations: gl.getUniformLocation(program, 'u_maxIterations'),
            colorScheme: gl.getUniformLocation(program, 'u_colorScheme'),
            fractalType: gl.getUniformLocation(program, 'u_fractalType'),
            juliaC: gl.getUniformLocation(program, 'u_juliaC'),
            time: gl.getUniformLocation(program, 'u_time')
        };

        // Create quad
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,   1, -1,   1, 1
        ]), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(locations.position);
        gl.vertexAttribPointer(locations.position, 2, gl.FLOAT, false, 0, 0);

        // Mouse/touch handling
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        let pinchDistance = 0;

        function screenToWorld(x, y) {
            const aspect = width / height;
            return {
                x: (x / width * 2 - 1) * aspect / zoom + centerX,
                y: (1 - y / height * 2) / zoom + centerY
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastPos = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const aspect = width / height;
            const dx = (e.clientX - lastPos.x) / width * 2 * aspect / zoom;
            const dy = (e.clientY - lastPos.y) / height * 2 / zoom;

            centerX -= dx;
            centerY += dy;

            lastPos = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('mouseleave', () => { isDragging = false; });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;

            // Zoom towards mouse position
            const before = screenToWorld(e.clientX, e.clientY);
            zoom *= zoomFactor;
            const after = screenToWorld(e.clientX, e.clientY);

            centerX += before.x - after.x;
            centerY += before.y - after.y;
        }, { passive: false });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                isDragging = true;
                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                pinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                const aspect = width / height;
                const dx = (e.touches[0].clientX - lastPos.x) / width * 2 * aspect / zoom;
                const dy = (e.touches[0].clientY - lastPos.y) / height * 2 / zoom;

                centerX -= dx;
                centerY += dy;

                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDistance = Math.sqrt(dx * dx + dy * dy);

                if (pinchDistance > 0) {
                    zoom *= newDistance / pinchDistance;
                }
                pinchDistance = newDistance;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            pinchDistance = 0;
        });

        // Control functions
        window.resetView = function() {
            centerX = fractalType === 0 ? -0.5 : 0;
            centerY = 0;
            zoom = 1;
            maxIterations = 100;
        };

        window.toggleFractal = function() {
            fractalType = 1 - fractalType;
            const btn = document.querySelectorAll('.control-btn')[1];
            btn.textContent = fractalType === 0 ? 'Julia Set' : 'Mandelbrot';
            btn.classList.toggle('active', fractalType === 1);
            resetView();
        };

        window.toggleColors = function() {
            colorScheme = (colorScheme + 1) % colorSchemes.length;
        };

        window.increaseIterations = function() {
            maxIterations = Math.min(maxIterations + 50, 500);
        };

        window.animateJulia = function() {
            animating = !animating;
            if (fractalType === 0) {
                fractalType = 1;
                document.querySelectorAll('.control-btn')[1].textContent = 'Mandelbrot';
                document.querySelectorAll('.control-btn')[1].classList.add('active');
            }
            document.querySelectorAll('.control-btn')[4].classList.toggle('active', animating);
        };

        // Update stats
        function updateStats() {
            const zoomLevel = zoom.toExponential(2);
            document.getElementById('stats').innerHTML =
                `Zoom: ${zoomLevel}<br>` +
                `Iter: ${maxIterations}<br>` +
                `${fractalType === 0 ? 'Mandelbrot' : 'Julia'}`;
        }

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            if (animating) {
                animationTime = time * 0.001;
                juliaC.x = -0.7 + Math.sin(animationTime * 0.5) * 0.2;
                juliaC.y = 0.27015 + Math.cos(animationTime * 0.7) * 0.2;
            }

            gl.uniform2f(locations.center, centerX, centerY);
            gl.uniform1f(locations.zoom, zoom);
            gl.uniform2f(locations.resolution, width, height);
            gl.uniform1i(locations.maxIterations, maxIterations);
            gl.uniform1i(locations.colorScheme, colorScheme);
            gl.uniform1i(locations.fractalType, fractalType);
            gl.uniform2f(locations.juliaC, juliaC.x, juliaC.y);
            gl.uniform1f(locations.time, time * 0.001);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            updateStats();
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
