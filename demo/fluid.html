<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fluid Simulation - MobileCLI Demos</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .info {
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 280px;
        }

        .info h3 {
            color: #00ff88;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .control-btn.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
            color: #00ff88;
        }

        @media (max-width: 600px) {
            .info { display: none; }
            .ui { top: 10px; left: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui">
        <a href="/demos.html" class="back-btn">‚Üê Back to Demos</a>
        <div class="info">
            <h3>Fluid Simulation</h3>
            <p>Touch or drag to create fluid motion. Double-tap to add color splashes. Based on Navier-Stokes equations.</p>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn" onclick="clearCanvas()">Clear</button>
        <button class="control-btn" onclick="toggleRainbow()">Rainbow</button>
        <button class="control-btn" onclick="addRandomSplat()">Splash</button>
        <button class="control-btn" onclick="togglePause()">Pause</button>
    </div>

    <script>
        // WebGL Fluid Simulation based on GPU Gems / Navier-Stokes
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Check for float texture support
        const ext = gl.getExtension('EXT_color_buffer_float') ||
                    gl.getExtension('WEBGL_color_buffer_float') ||
                    gl.getExtension('OES_texture_float');

        // Configuration
        const config = {
            SIM_RESOLUTION: 256,
            DYE_RESOLUTION: 1024,
            DENSITY_DISSIPATION: 0.97,
            VELOCITY_DISSIPATION: 0.98,
            PRESSURE_ITERATIONS: 20,
            CURL: 30,
            SPLAT_RADIUS: 0.25,
            SPLAT_FORCE: 6000,
            SHADING: true,
            COLORFUL: true,
            PAUSED: false,
        };

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vertexSource, fragmentSource) {
            const program = gl.createProgram();
            const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Base vertex shader
        const baseVertexShader = `
            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;

            void main() {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        // Display shader
        const displayShader = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform float uTime;

            void main() {
                vec3 color = texture2D(uTexture, vUv).rgb;

                // Add subtle vignette
                vec2 center = vUv - 0.5;
                float vignette = 1.0 - dot(center, center) * 0.5;
                color *= vignette;

                // Tone mapping
                color = color / (1.0 + color);
                color = pow(color, vec3(0.85));

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Splat shader
        const splatShader = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;

            void main() {
                vec2 p = vUv - point;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).rgb;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `;

        // Advection shader
        const advectionShader = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float dt;
            uniform float dissipation;

            void main() {
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                vec3 result = dissipation * texture2D(uSource, coord).rgb;
                gl_FragColor = vec4(result, 1.0);
            }
        `;

        // Divergence shader
        const divergenceShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;

            void main() {
                float L = texture2D(uVelocity, vL).x;
                float R = texture2D(uVelocity, vR).x;
                float T = texture2D(uVelocity, vT).y;
                float B = texture2D(uVelocity, vB).y;
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;

        // Pressure shader
        const pressureShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;

            void main() {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                float C = texture2D(uPressure, vUv).x;
                float divergence = texture2D(uDivergence, vUv).x;
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `;

        // Gradient subtract shader
        const gradientSubtractShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;

            void main() {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        // Curl shader
        const curlShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;

            void main() {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
            }
        `;

        // Vorticity shader
        const vorticityShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uCurl;
            uniform float curl;
            uniform float dt;

            void main() {
                float L = texture2D(uCurl, vL).x;
                float R = texture2D(uCurl, vR).x;
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;

                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= curl * C;
                force.y *= -1.0;

                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity += force * dt;
                velocity = min(max(velocity, -1000.0), 1000.0);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        // Clear shader
        const clearShader = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;

            void main() {
                gl_FragColor = value * texture2D(uTexture, vUv);
            }
        `;

        // Create programs
        const displayProgram = createProgram(baseVertexShader, displayShader);
        const splatProgram = createProgram(baseVertexShader, splatShader);
        const advectionProgram = createProgram(baseVertexShader, advectionShader);
        const divergenceProgram = createProgram(baseVertexShader, divergenceShader);
        const pressureProgram = createProgram(baseVertexShader, pressureShader);
        const gradientSubtractProgram = createProgram(baseVertexShader, gradientSubtractShader);
        const curlProgram = createProgram(baseVertexShader, curlShader);
        const vorticityProgram = createProgram(baseVertexShader, vorticityShader);
        const clearProgram = createProgram(baseVertexShader, clearShader);

        // Create vertex buffer
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);

        // Framebuffer helper
        function createFBO(w, h, internalFormat, format, type, filter) {
            gl.activeTexture(gl.TEXTURE0);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT);

            return {
                texture,
                fbo,
                width: w,
                height: h,
                attach(id) {
                    gl.activeTexture(gl.TEXTURE0 + id);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    return id;
                }
            };
        }

        function createDoubleFBO(w, h, internalFormat, format, type, filter) {
            let fbo1 = createFBO(w, h, internalFormat, format, type, filter);
            let fbo2 = createFBO(w, h, internalFormat, format, type, filter);
            return {
                width: w,
                height: h,
                texelSizeX: 1.0 / w,
                texelSizeY: 1.0 / h,
                get read() { return fbo1; },
                set read(value) { fbo1 = value; },
                get write() { return fbo2; },
                set write(value) { fbo2 = value; },
                swap() { [fbo1, fbo2] = [fbo2, fbo1]; }
            };
        }

        // Determine texture format support
        let texType = gl.UNSIGNED_BYTE;
        let rgba = { internalFormat: gl.RGBA, format: gl.RGBA };
        let rg = { internalFormat: gl.RGBA, format: gl.RGBA };
        let r = { internalFormat: gl.RGBA, format: gl.RGBA };

        if (gl instanceof WebGL2RenderingContext) {
            texType = gl.HALF_FLOAT;
            rgba = { internalFormat: gl.RGBA16F, format: gl.RGBA };
            rg = { internalFormat: gl.RG16F, format: gl.RG };
            r = { internalFormat: gl.R16F, format: gl.RED };
        }

        // Create framebuffers
        const simWidth = config.SIM_RESOLUTION;
        const simHeight = config.SIM_RESOLUTION;
        const dyeWidth = config.DYE_RESOLUTION;
        const dyeHeight = config.DYE_RESOLUTION;

        let dye = createDoubleFBO(dyeWidth, dyeHeight, rgba.internalFormat, rgba.format, texType, gl.LINEAR);
        let velocity = createDoubleFBO(simWidth, simHeight, rgba.internalFormat, rgba.format, texType, gl.LINEAR);
        let divergence = createFBO(simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);
        let curl = createFBO(simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);
        let pressure = createDoubleFBO(simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);

        // Blit helper
        function blit(target) {
            if (target) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                gl.viewport(0, 0, target.width, target.height);
            } else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        // Setup attribute
        function setupVertexAttrib(program) {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        // Color generation
        function generateColor() {
            const c = HSVtoRGB(Math.random(), 1.0, 1.0);
            return { r: c.r * 0.15, g: c.g * 0.15, b: c.b * 0.15 };
        }

        function HSVtoRGB(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return { r, g, b };
        }

        // Splat function
        function splat(x, y, dx, dy, color) {
            setupVertexAttrib(splatProgram);
            gl.useProgram(splatProgram);

            gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), velocity.read.attach(0));
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
            gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), x, y);
            gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), dx, dy, 0.0);
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), config.SPLAT_RADIUS / 100.0);
            blit(velocity.write);
            velocity.swap();

            gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), dye.read.attach(0));
            gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), color.r, color.g, color.b);
            blit(dye.write);
            dye.swap();
        }

        // Input handling
        let pointers = [];
        let lastPointer = null;
        let rainbowMode = true;
        let hue = 0;

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (x - rect.left) / rect.width,
                y: 1.0 - (y - rect.top) / rect.height
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            lastPointer = getPointerPos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!lastPointer) return;
            const pos = getPointerPos(e);
            const dx = (pos.x - lastPointer.x) * config.SPLAT_FORCE;
            const dy = (pos.y - lastPointer.y) * config.SPLAT_FORCE;

            if (rainbowMode) {
                hue = (hue + 0.01) % 1;
            }
            const color = HSVtoRGB(hue, 1.0, 1.0);
            splat(pos.x, pos.y, dx, dy, { r: color.r * 0.2, g: color.g * 0.2, b: color.b * 0.2 });
            lastPointer = pos;
        });

        canvas.addEventListener('mouseup', () => { lastPointer = null; });
        canvas.addEventListener('mouseleave', () => { lastPointer = null; });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            lastPointer = getPointerPos(e);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!lastPointer) return;
            const pos = getPointerPos(e);
            const dx = (pos.x - lastPointer.x) * config.SPLAT_FORCE;
            const dy = (pos.y - lastPointer.y) * config.SPLAT_FORCE;

            if (rainbowMode) {
                hue = (hue + 0.01) % 1;
            }
            const color = HSVtoRGB(hue, 1.0, 1.0);
            splat(pos.x, pos.y, dx, dy, { r: color.r * 0.2, g: color.g * 0.2, b: color.b * 0.2 });
            lastPointer = pos;
        }, { passive: false });

        canvas.addEventListener('touchend', () => { lastPointer = null; });

        // Double tap for random splat
        let lastTap = 0;
        canvas.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) {
                addRandomSplat();
            }
            lastTap = now;
        });

        // Control functions
        window.clearCanvas = function() {
            setupVertexAttrib(clearProgram);
            gl.useProgram(clearProgram);
            gl.uniform1f(gl.getUniformLocation(clearProgram, 'value'), 0.0);

            gl.uniform1i(gl.getUniformLocation(clearProgram, 'uTexture'), dye.read.attach(0));
            blit(dye.write);
            dye.swap();

            gl.uniform1i(gl.getUniformLocation(clearProgram, 'uTexture'), velocity.read.attach(0));
            blit(velocity.write);
            velocity.swap();
        };

        window.toggleRainbow = function() {
            rainbowMode = !rainbowMode;
            document.querySelectorAll('.control-btn')[1].classList.toggle('active', rainbowMode);
        };

        window.addRandomSplat = function() {
            const color = generateColor();
            const x = Math.random();
            const y = Math.random();
            const dx = (Math.random() - 0.5) * 1000;
            const dy = (Math.random() - 0.5) * 1000;
            splat(x, y, dx, dy, color);
        };

        window.togglePause = function() {
            config.PAUSED = !config.PAUSED;
            document.querySelectorAll('.control-btn')[3].classList.toggle('active', config.PAUSED);
        };

        // Simulation step
        function step(dt) {
            // Curl
            setupVertexAttrib(curlProgram);
            gl.useProgram(curlProgram);
            gl.uniform2f(gl.getUniformLocation(curlProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(curlProgram, 'uVelocity'), velocity.read.attach(0));
            blit(curl);

            // Vorticity
            setupVertexAttrib(vorticityProgram);
            gl.useProgram(vorticityProgram);
            gl.uniform2f(gl.getUniformLocation(vorticityProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(vorticityProgram, 'uVelocity'), velocity.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(vorticityProgram, 'uCurl'), curl.attach(1));
            gl.uniform1f(gl.getUniformLocation(vorticityProgram, 'curl'), config.CURL);
            gl.uniform1f(gl.getUniformLocation(vorticityProgram, 'dt'), dt);
            blit(velocity.write);
            velocity.swap();

            // Divergence
            setupVertexAttrib(divergenceProgram);
            gl.useProgram(divergenceProgram);
            gl.uniform2f(gl.getUniformLocation(divergenceProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(divergenceProgram, 'uVelocity'), velocity.read.attach(0));
            blit(divergence);

            // Clear pressure
            setupVertexAttrib(clearProgram);
            gl.useProgram(clearProgram);
            gl.uniform1i(gl.getUniformLocation(clearProgram, 'uTexture'), pressure.read.attach(0));
            gl.uniform1f(gl.getUniformLocation(clearProgram, 'value'), 0.8);
            blit(pressure.write);
            pressure.swap();

            // Pressure iterations
            setupVertexAttrib(pressureProgram);
            gl.useProgram(pressureProgram);
            gl.uniform2f(gl.getUniformLocation(pressureProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uDivergence'), divergence.attach(0));
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uPressure'), pressure.read.attach(1));
                blit(pressure.write);
                pressure.swap();
            }

            // Gradient subtract
            setupVertexAttrib(gradientSubtractProgram);
            gl.useProgram(gradientSubtractProgram);
            gl.uniform2f(gl.getUniformLocation(gradientSubtractProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uPressure'), pressure.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uVelocity'), velocity.read.attach(1));
            blit(velocity.write);
            velocity.swap();

            // Advect velocity
            setupVertexAttrib(advectionProgram);
            gl.useProgram(advectionProgram);
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), velocity.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), velocity.read.attach(0));
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dt'), dt);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), config.VELOCITY_DISSIPATION);
            blit(velocity.write);
            velocity.swap();

            // Advect dye
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), dye.texelSizeX, dye.texelSizeY);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), velocity.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), dye.read.attach(1));
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), config.DENSITY_DISSIPATION);
            blit(dye.write);
            dye.swap();
        }

        // Render
        function render() {
            setupVertexAttrib(displayProgram);
            gl.useProgram(displayProgram);
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uTexture'), dye.read.attach(0));
            gl.uniform1f(gl.getUniformLocation(displayProgram, 'uTime'), performance.now() / 1000);
            blit(null);
        }

        // Animation loop
        let lastTime = performance.now();

        function animate() {
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.016);
            lastTime = now;

            if (!config.PAUSED) {
                step(dt);
            }
            render();

            requestAnimationFrame(animate);
        }

        // Initial splats
        for (let i = 0; i < 5; i++) {
            setTimeout(() => addRandomSplat(), i * 200);
        }

        // Initialize rainbow button state
        document.querySelectorAll('.control-btn')[1].classList.add('active');

        animate();
    </script>
</body>
</html>
